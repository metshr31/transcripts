name: Record & Transcribe (HLS)

on:
  workflow_dispatch:
    inputs:
      page_url:
        description: "Public webcast/player PAGE URL (not the .m3u8)"
        required: true
      duration_sec:
        description: "Optional hard stop in seconds (leave blank to let stream end naturally)"
        required: false
        default: ""

jobs:
  call:
    runs-on: ubuntu-latest
    env:
      OUT_DIR: out

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # ---- Playwright capture (gets the real .m3u8 + cookies/headers) ----
      - name: Install Playwright + deps
        run: |
          python -m pip install --upgrade pip
          pip install playwright
          python -m playwright install --with-deps chromium

      - name: Capture HLS manifest with Playwright
        env:
          PAGE_URL: ${{ github.event.inputs.page_url }}
          OUT_DIR: ${{ env.OUT_DIR }}
        run: |
          mkdir -p "${OUT_DIR}"
          python scripts/capture_manifest.py
          echo "Captured files in ${OUT_DIR}:"
          ls -la "${OUT_DIR}"

      # ---- Recording tools ----
      - name: Install ffmpeg, streamlink, jq
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg streamlink jq
          ffmpeg -version
          streamlink --version

      # ---- Verify outputs from capture step ----
      - name: Verify exported artifacts exist
        env:
          M3U8: ${{ env.OUT_DIR }}/manifest.m3u8
          MTXT: ${{ env.OUT_DIR }}/manifest.txt
          COOK: ${{ env.OUT_DIR }}/cookies.json
        run: |
          set -euo pipefail
          test -s "$COOK" || { echo "❌ Missing cookies JSON: $COOK"; exit 3; }
          if [ ! -s "$M3U8" ] && [ ! -s "$MTXT" ]; then
            echo "❌ No manifest found at $M3U8 or $MTXT"
            exit 2
          fi
          echo "✅ Found cookies + (m3u8 or text manifest)"

      - name: Extract HLS URL
        id: hls
        env:
          M3U8: ${{ env.OUT_DIR }}/manifest.m3u8
          MTXT: ${{ env.OUT_DIR }}/manifest.txt
        run: |
          set -euo pipefail
          if [ -s "$M3U8" ]; then
            URL="$(sed -n '1p' "$M3U8")"
          else
            URL="$(grep -Eo 'https?://[^ ]+\.m3u8[^ ]*' "$MTXT" | head -n1)"
          fi
          [ -n "${URL:-}" ] || { echo "❌ Could not extract .m3u8 URL"; exit 4; }
          echo "url=$URL" >> "$GITHUB_OUTPUT"
          echo "HLS URL: $URL"

      - name: Build auth for streamlink/ffmpeg
        id: auth
        env:
          COOK: ${{ env.OUT_DIR }}/cookies.json
          HDRS: ${{ env.OUT_DIR }}/headers.json
        run: |
          set -euo pipefail
          # Streamlink cookies: one --http-cookie per cookie
          SL_COOKIES="$(jq -r '.[] | "--http-cookie \(.name)=\(.value)"' "$COOK" | xargs || true)"
          echo "sl_cookies=${SL_COOKIES}" >> "$GITHUB_OUTPUT"

          # Build a single headers file for ffmpeg
          HDR_FILE=headers.txt
          COOKIE_HDR="$(jq -r '.[] | "\(.name)=\(.value)"' "$COOK" | paste -sd'; ' -)"
          echo "Cookie: ${COOKIE_HDR}" > "$HDR_FILE"

          if [ -s "$HDRS" ]; then
            jq -r '.[] | "\(.name): \(.value)"' "$HDRS" >> "$HDR_FILE"
          fi

          echo "hdr_file=${HDR_FILE}" >> "$GITHUB_OUTPUT"
          echo "Wrote headers to ${HDR_FILE}:"
          cat "$HDR_FILE"

      - name: Record audio (Streamlink → ffmpeg fallback; verbose)
        env:
          URL: ${{ steps.hls.outputs.url }}
          SL_COOKIES: ${{ steps.auth.outputs.sl_cookies }}
          HDR_FILE: ${{ steps.auth.outputs.hdr_file }}
          DURATION: ${{ github.event.inputs.duration_sec }}
        run: |
          set -euo pipefail

          retry() {
            n=0
            until [ "$n" -ge 2 ]; do
              "$@" && return 0
              n=$((n+1))
              echo "Retry $n/2 after failure..."
              sleep 3
            done
            return 1
          }

          # If you pass a duration, use it for both tools
          DUR_ARG=""
          if [ -n "${DURATION:-}" ]; then
            DUR_ARG_FFMPEG="-t ${DURATION}"
          fi

          echo "=== STREAMLINK (debug) ==="
          if ! retry bash -lc 'streamlink -l debug ${SL_COOKIES} --hls-live-restart "$URL" best -o stream.ts'; then
            echo "Streamlink failed; switching to ffmpeg…"
            echo "=== FFMPEG (verbose) ==="
            HDRS="$(tr "\n" "\r\n" < "$HDR_FILE")"
            retry bash -lc 'ffmpeg -nostdin -loglevel verbose -headers "$HDRS" -i "$URL" '"${DUR_ARG_FFMPEG:-}"' -vn -acodec copy audio.m4a'
          else
            echo "Converting TS → M4A (audio only)"
            ffmpeg -nostdin -loglevel verbose -i stream.ts -vn -acodec copy audio.m4a
          fi

          test -s audio.m4a || { echo "❌ audio.m4a not created"; exit 5; }
          echo "✅ Recorded audio.m4a"

      - name: Upload audio artifact
        uses: actions/upload-artifact@v4
        with:
          name: audio
          path: audio.m4a
          if-no-files-found: error

      # ---- OPTIONAL: Transcribe with Whisper CLI (uncomment if desired) ----
      # - name: Install whisper
      #   run: |
      #     pip install openai-whisper
      #     sudo apt-get install -y ffmpeg
      #
      # - name: Transcribe
      #   run: |
      #     mkdir -p out
      #     whisper audio.m4a --language en --model small --output_dir out
      #
      # - name: Upload transcript
      #   uses: actions/upload-artifact@v4
      #   with:
      #     name: transcript
      #     path: out/*