name: Reusable - Record & Transcribe HLS (with diarization + email)

on:
  workflow_call:
    inputs:
      url:
        required: true
        type: string
      minutes:
        required: false
        type: string
        default: "35"
      model:
        required: false
        type: string
        default: "small"
      probe_seconds:
        required: false
        type: string
        default: "0"
      diarize:
        required: false
        type: boolean
        default: false
      max_speakers:
        required: false
        type: string
        default: "0"
    secrets:
      FIRST:
        required: true
      LAST:
        required: true
      COMPANY:
        required: true
      EMAIL:
        required: true
      HF_TOKEN:
        required: false
      SMTP_SERVER:
        required: false
      SMTP_PORT:
        required: false
      SMTP_USERNAME:
        required: false
      SMTP_PASSWORD:
        required: false
      MAIL_FROM:
        required: false
      MAIL_TO:
        required: false

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install tools (Playwright, ffmpeg, Streamlink, Whisper)
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq streamlink
          python -m pip install --upgrade pip
          python -m pip install playwright openai-whisper
          python -m playwright install --with-deps chromium

      - name: Create inline Playwright capture helper
        run: |
          cat > /tmp/hls_capture_inline.py <<'PY'
          import os, json, asyncio, re
          from urllib.parse import urlparse
          from playwright.async_api import async_playwright
          URL=os.environ["EVENT_URL"]; FIRST=os.environ["FIRST"]; LAST=os.environ["LAST"]; COMPANY=os.environ["COMPANY"]; EMAIL=os.environ["EMAIL"]
          LABELS={"First Name":FIRST,"Last Name":LAST,"Company":COMPANY,"Email":EMAIL}
          M3U8_RE=re.compile(r"\.m3u8(\?.*)?$", re.IGNORECASE)
          async def main():
              async with async_playwright() as p:
                  b=await p.chromium.launch(headless=True); c=await b.new_context(); pg=await c.new_page()
                  found={"url":None,"headers":{}}
                  async def on_resp(r):
                      try:
                          u=r.url
                          if M3U8_RE.search(u) and not found["url"]:
                              found["url"]=u
                              found["headers"]["Referer"]=pg.url
                              pr=urlparse(pg.url); found["headers"]["Origin"]=f"{pr.scheme}://{pr.netloc}"
                      except: pass
                  pg.on("response", on_resp)
                  await pg.goto(URL, wait_until="domcontentloaded")
                  for lab,val in LABELS.items():
                      try: await pg.get_by_label(lab, exact=True).fill(val)
                      except: pass
                  async def tf(sel,val):
                      try: await pg.fill(sel,val); return True
                      except: return False
                  await tf("input[name='firstName']",FIRST); await tf("input[name='firstname']",FIRST); await tf("input[placeholder='First Name']",FIRST)
                  await tf("input[name='lastName']",LAST);  await tf("input[name='lastname']",LAST);  await tf("input[placeholder='Last Name']",LAST)
                  await tf("input[name='company']",COMPANY); await tf("input[placeholder='Company']",COMPANY)
                  await tf("input[name='email']",EMAIL);   await tf("input[type='email']",EMAIL)
                  for sel in ["button[type='submit']","input[type='submit']","button:has-text('Enter')","button:has-text('Register')","button:has-text('Log In')","button:has-text('Watch')"]:
                      try: await pg.click(sel); break
                      except: pass
                  await pg.wait_for_load_state("networkidle", timeout=60000)
                  for _ in range(60):
                      if found["url"]: break
                      await asyncio.sleep(1)
                  ck=await c.cookies()
                  cookie="; ".join(f"{x['name']}={x['value']}" for x in ck) if ck else ""
                  json.dump({"m3u8_url":found["url"],"headers":found["headers"],"cookies":cookie}, open("session_info.json","w"))
                  print("Captured:", json.dumps({"has_m3u8": bool(found["url"])}))
                  await b.close()
          if __name__=="__main__": asyncio.run(main())
          PY

      - name: Login & capture HLS info (auto-skip for .m3u8)
        env:
          EVENT_URL: ${{ inputs.url }}
          FIRST:     ${{ secrets.FIRST }}
          LAST:      ${{ secrets.LAST }}
          COMPANY:   ${{ secrets.COMPANY }}
          EMAIL:     ${{ secrets.EMAIL }}
        run: |
          if echo "$EVENT_URL" | grep -Eiq '\.m3u8(\?.*)?$'; then
            echo "Direct .m3u8 detected; skipping Playwright."
            printf '%s\n' \
              '{' \
              "  \"m3u8_url\": \"${EVENT_URL}\"," \
              '  "headers": {},' \
              '  "cookies": ""' \
              '}' > session_info.json
          else
            echo "Not a direct .m3u8; using Playwright to capture."
            python /tmp/hls_capture_inline.py
          fi
          echo "== session_info.json (sanitized) =="
          cat session_info.json | jq '{m3u8_url, headers: (.headers|keys), has_cookies: (.cookies|length>0)}'

      - name: Record audio (ffmpeg with reconnect; Streamlink fallback)
        id: rec
        env:
          MINUTES: ${{ inputs.minutes }}
          PROBE:   ${{ inputs.probe_seconds }}
        run: |
          mkdir -p recordings
          URL=$(jq -r '.m3u8_url' session_info.json)
          REF=$(jq -r '.headers.Referer // empty' session_info.json)
          ORG=$(jq -r '.headers.Origin // empty' session_info.json)
          CK=$(jq -r '.cookies // empty' session_info.json)

          if [ -n "$PROBE" ] && [ "$PROBE" != "0" ]; then
            DURATION=$PROBE
          else
            DURATION=$((MINUTES*60))
          fi

          TS=$(date -u +"%Y%m%d-%H%M%S"); OUT="recordings/event-${TS}.m4a"
          HDRS=""
          [ -n "$CK" ]  && HDRS="${HDRS}Cookie: ${CK}\r\n"
          [ -n "$REF" ] && HDRS="${HDRS}Referer: ${REF}\r\n"
          [ -n "$ORG" ] && HDRS="${HDRS}Origin: ${ORG}\r\n"

          RECORD_CMD='ffmpeg -hide_banner -loglevel error -reconnect 1 -reconnect_streamed 1 -reconnect_at_eof 1 -rw_timeout 15000000 -user_agent "Mozilla/5.0" -headers "$HDRS" -i "$URL" -t $DURATION -vn -c:a aac -b:a 128k "$OUT"'

          if [ -n "$URL" ] && [ "$URL" != "null" ]; then
            echo "Trying ffmpeg directly..."
            if eval $RECORD_CMD; then
              echo "OK via ffmpeg"
            else
              echo "ffmpeg failed; trying Streamlink..."
              if streamlink --http-header "Cookie=$CK" --http-header "Referer=$REF" --http-header "Origin=$ORG" "$URL" best -O | \
                 ffmpeg -hide_banner -loglevel error -i - -t $DURATION -vn -c:a aac -b:a 128k "$OUT"; then
                echo "OK via Streamlink"
              else
                echo "Both ffmpeg and Streamlink failed."; exit 1
              fi
            fi
          else
            echo "No m3u8 captured; trying Streamlink on page URL..."
            PAGE_URL="${{ inputs.url }}"
            if streamlink --http-header "Cookie=$CK" --http-header "Referer=$REF" --http-header "Origin=$ORG" "$PAGE_URL" best -O | \
               ffmpeg -hide_banner -loglevel error -i - -t $DURATION -vn -c:a aac -b:a 128k "$OUT"; then
              echo "OK via Streamlink (page URL)"
            else
              echo "Fallback failed."; exit 1
            fi
          fi

          echo "out_file=$OUT" >> $GITHUB_OUTPUT

      - name: Transcribe with Whisper (CLI)
        run: |
          set -e
          FILE=$(ls -1 recordings/event-*.m4a | tail -n 1 || true)
          if [ -z "$FILE" ] || [ ! -f "$FILE" ]; then
            echo "No recording found"; exit 1
          fi
          whisper "$FILE" --model "${{ inputs.model }}" \
            --task transcribe \
            --output_format all \
            --output_dir recordings \
            --verbose False

      - name: (Optional) Install diarization deps
        if: ${{ inputs.diarize == true }}
        run: |
          python -m pip install --upgrade pip
          pip install --index-url https://download.pytorch.org/whl/cpu torch torchvision torchaudio
          pip install pyannote.audio==3.* numpy==1.*

      - name: (Optional) Diarize and merge with Whisper transcript
        if: ${{ inputs.diarize == true }}
        env:
          HF_TOKEN: ${{ secrets.HF_TOKEN }}
          MAX_SPK:  ${{ inputs.max_speakers }}
        run: |
          set -e
          AUDIO=$(ls -1 recordings/event-*.m4a | tail -n 1)
          if [ -z "$AUDIO" ]; then
            echo "No audio file for diarization"; exit 1
          fi
          if [ -z "$HF_TOKEN" ]; then
            echo "HF_TOKEN not set"; exit 1
          fi
          python <<'PY'
          import os, json
          from pathlib import Path
          from pyannote.audio import Pipeline

          out_dir = Path("recordings")
          audio = sorted(out_dir.glob("event-*.m4a"))[-1]
          wjson_files = list(out_dir.glob("*.json"))
          whisper_json = None
          if wjson_files:
              whisper_json = json.loads(wjson_files[0].read_text(encoding="utf-8"))

          token = os.environ["HF_TOKEN"]
          n = os.environ.get("MAX_SPK", "0")
          num_speakers = int(n) if n.isdigit() and int(n) > 0 else None

          pipeline = Pipeline.from_pretrained("pyannote/speaker-diarization-3.1", use_auth_token=token)
          diarization = pipeline(str(audio), num_speakers=num_speakers)

          with open(out_dir / "diarization.rttm","w") as f:
              diarization.write_rttm(f)

          def fmt_ts(sec):
              ms = int((sec - int(sec))*1000)
              h = int(sec//3600); m=int((sec%3600)//60); s=int(sec%60)
              return f"{h:02d}:{m:02d}:{s:02d}.{ms:03d}"

          if not whisper_json or "segments" not in whisper_json:
              lines=[]
              i=1
              for turn,_,lab in diarization.itertracks(yield_label=True):
                  lines += [str(i), f"{fmt_ts(turn.start)} --> {fmt_ts(turn.end)}", lab, ""]
                  i+=1
              (out_dir/"event-diarized.srt").write_text("\n".join(lines), encoding="utf-8")
          else:
              diarized=[]
              for seg in whisper_json["segments"]:
                  st=float(seg.get("start",0)); en=float(seg.get("end",st)); mid=(st+en)/2.0
                  lab="SPEAKER_UNKNOWN"
                  for turn,_,speaker in diarization.itertracks(yield_label=True):
                      if turn.start <= mid <= turn.end:
                          lab=speaker; break
                  diarized.append({"start":st,"end":en,"speaker":lab,"text":seg.get("text","").strip()})

              (out_dir/"event-diarized.txt").write_text(
                  "\n".join(f'{d["speaker"]}: {d["text"]}' for d in diarized if d["text"]),
                  encoding="utf-8"
              )
          PY

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: audio-and-transcripts
          path: recordings/*
          retention-days: 14

      - name: Email completion notice
        if: ${{ always() }}
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.SMTP_SERVER }}
          server_port: ${{ secrets.SMTP_PORT }}
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          from: ${{ secrets.MAIL_FROM }}
          to: ${{ secrets.MAIL_TO }}
          secure: true
          subject: "ðŸŽ§ [${{ github.workflow }}] â€” ${{ job.status }}"
          content_type: text/html
          body: |
            <h3>Workflow finished: <b>${{ github.workflow }}</b></h3>
            <ul>
              <li><b>Status:</b> ${{ job.status }}</li>
              <li><b>Repository:</b> ${{ github.repository }}</li>
              <li><b>Event URL:</b> ${{ inputs.url }}</li>
              <li><b>Duration:</b> ${{ inputs.probe_seconds != '0' && format('{0}s (probe)', inputs.probe_seconds) || format('{0} min', inputs.minutes) }}</li>
              <li><b>Artifacts:</b> audio-and-transcripts</li>
              <li><b>Run:</b> <a href="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}">Open in GitHub</a></li>
            </ul>
          attachments: |
            recordings/event-diarized.txt
            recordings/*.txt
