name: Reusable - Record & Transcribe HLS (with diarization + email + screenshot)

on:
  workflow_call:
    inputs:
      url:
        required: true
        type: string
      minutes:
        required: false
        type: string
        default: "35"
      model:
        required: false
        type: string
        default: "small"
      probe_seconds:
        required: false
        type: string
        default: "0"
      diarize:
        required: false
        type: boolean
        default: false
      max_speakers:
        required: false
        type: string
        default: "0"
    secrets:
      FIRST:
        required: true
      LAST:
        required: true
      COMPANY:
        required: true
      EMAIL:
        required: true
      HF_TOKEN:
        required: false
      SMTP_SERVER:
        required: false
      SMTP_PORT:
        required: false
      SMTP_USERNAME:
        required: false
      SMTP_PASSWORD:
        required: false
      MAIL_FROM:
        required: false
      MAIL_TO:
        required: false

jobs:
  run:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install tools (Playwright, ffmpeg, Streamlink, Whisper)
        run: |
          sudo apt-get update
          sudo apt-get install -y ffmpeg jq streamlink
          python -m pip install --upgrade pip
          python -m pip install playwright openai-whisper
          python -m playwright install --with-deps chromium

      - name: Create inline Playwright capture helper (with screenshot)
        run: |
          cat > /tmp/hls_capture_inline.py <<'PY'
          import os, json, asyncio, re, time, pathlib
          from urllib.parse import urlparse
          from playwright.async_api import async_playwright

          URL=os.environ["EVENT_URL"]; FIRST=os.environ["FIRST"]; LAST=os.environ["LAST"]; COMPANY=os.environ["COMPANY"]; EMAIL=os.environ["EMAIL"]
          LABELS={"First Name":FIRST,"Last Name":LAST,"Company":COMPANY,"Email":EMAIL}
          M3U8_RE=re.compile(r"\.m3u8(\?.*)?$", re.IGNORECASE)

          async def try_click_play(frame):
              selectors = [
                  ".vjs-big-play-button",
                  "button[aria-label='Play']",
                  "button:has-text('Play')",
                  "div[role='button']:has-text('Play')",
                  "button.ytp-large-play-button"
              ]
              for sel in selectors:
                  try:
                      el = frame.locator(sel)
                      if await el.count() > 0:
                          await el.first.click(timeout=1000)
                          return True
                  except: pass
              # spacebar can start playback on some players
              try:
                  await frame.press("body", " ")
              except: pass
              return False

          async def main():
              pathlib.Path("recordings").mkdir(parents=True, exist_ok=True)
              async with async_playwright() as p:
                  b=await p.chromium.launch(headless=True)
                  ctx=await b.new_context()
                  pg=await ctx.new_page()
                  found={"url":None,"headers":{}}

                  def maybe_take(u, frame_url):
                      if M3U8_RE.search(u) and not found["url"]:
                          found["url"]=u
                          found["headers"]["Referer"]=pg.url
                          pr=urlparse(pg.url); found["headers"]["Origin"]=f"{pr.scheme}://{pr.netloc}"

                  # Watch top-level and frames
                  pg.on("request", lambda r: maybe_take(r.url, pg.url))
                  pg.on("response", lambda r: maybe_take(r.url, pg.url))

                  await pg.goto(URL, wait_until="domcontentloaded")

                  # Fill by labels
                  for lab,val in LABELS.items():
                      try: await pg.get_by_label(lab, exact=True).fill(val)
                      except: pass

                  # Generic fallbacks
                  async def tf(sel,val):
                      try: await pg.fill(sel,val); return True
                      except: return False
                  await tf("input[name='firstName']",FIRST); await tf("input[name='firstname']",FIRST); await tf("input[placeholder='First Name']",FIRST)
                  await tf("input[name='lastName']",LAST);  await tf("input[name='lastname']",LAST);  await tf("input[placeholder='Last Name']",LAST)
                  await tf("input[name='company']",COMPANY); await tf("input[placeholder='Company']",COMPANY)
                  await tf("input[name='email']",EMAIL);   await tf("input[type='email']",EMAIL)

                  # Submit
                  for sel in ["button[type='submit']","input[type='submit']","button:has-text('Enter')","button:has-text('Register')","button:has-text('Log In')","button:has-text('Watch')"]:
                      try: await pg.click(sel, timeout=1000); break
                      except: pass

                  # Hook existing frames
                  for fr in pg.frames:
                      fr.on("request", lambda r: maybe_take(r.url, fr.url))
                      fr.on("response", lambda r: maybe_take(r.url, fr.url))
                  # Hook future frames
                  pg.on("frameattached", lambda fr: (fr.on("request", lambda r: maybe_take(r.url, fr.url)),
                                                     fr.on("response", lambda r: maybe_take(r.url, fr.url))))

                  # Let things settle
                  try:
                      await pg.wait_for_load_state("networkidle", timeout=120000)
                  except: pass

                  # Click Play in all frames
                  for fr in pg.frames:
                      try: await try_click_play(fr)
                      except: pass

                  # Wait up to 3 minutes for a manifest to show
                  t0=time.time()
                  while not found["url"] and (time.time()-t0)<180:
                      await asyncio.sleep(1)

                  # Screenshot for debugging (always)
                  try:
                      await pg.screenshot(path="recordings/page_after_capture.jpg", full_page=True)
                  except: pass
                  try:
                      # Save top-level HTML too (sometimes helpful)
                      html = await pg.content()
                      open("recordings/page_after_capture.html","w",encoding="utf-8").write(html)
                  except: pass

                  # Cookies
                  ck=await ctx.cookies()
                  cookie="; ".join(f"{c['name']}={c['value']}" for c in ck) if ck else ""
                  json.dump({"m3u8_url":found["url"],"headers":found["headers"],"cookies":cookie}, open("session_info.json","w"))
                  print("Captured:", json.dumps({"has_m3u8": bool(found['url'])}))
                  await b.close()

          if __name__=="__main__":
              asyncio.run(main())
          PY

      - name: Login & capture HLS info
        env:
          EVENT_URL: ${{ inputs.url }}
          FIRST:     ${{ secrets.FIRST }}
          LAST:      ${{ secrets.LAST }}
          COMPANY:   ${{ secrets.COMPANY }}
          EMAIL:     ${{ secrets.EMAIL }}
        run: |
          if echo "$EVENT_URL" | grep -Eiq '\.m3u8(\?.*)?$'; then
            echo "Direct .m3u8 detected; skipping Playwright."
            printf '%s\n' \
              '{' \
              "  \"m3u8_url\": \"${EVENT_URL}\"," \
              '  "headers": {},' \
              '  "cookies": ""' \
              '}' > session_info.json
          else
            echo "Not a direct .m3u8; using Playwright to capture."
            python /tmp/hls_capture_inline.py
          fi
          echo "== session_info.json =="
          cat session_info.json || true
          echo "== If present, screenshot saved to recordings/page_after_capture.jpg and HTML to recordings/page_after_capture.html =="

      - name: Record audio
        id: rec
        env:
          MINUTES: ${{ inputs.minutes }}
          PROBE:   ${{ inputs.probe_seconds }}
        run: |
          mkdir -p recordings
          URL=$(jq -r '.m3u8_url' session_info.json)
          REF=$(jq -r '.headers.Referer // empty' session_info.json)
          ORG=$(jq -r '.headers.Origin // empty' session_info.json)
          CK=$(jq -r '.cookies // empty' session_info.json)

          if [ -n "$PROBE" ] && [ "$PROBE" != "0" ]; then
            DURATION=$PROBE
          else
            DURATION=$((MINUTES*60))
          fi

          TS=$(date -u +"%Y%m%d-%H%M%S"); OUT="recordings/event-${TS}.m4a"
          HDRS=""
          [ -n "$CK" ]  && HDRS="${HDRS}Cookie: ${CK}\r\n"
          [ -n "$REF" ] && HDRS="${HDRS}Referer: ${REF}\r\n"
          [ -n "$ORG" ] && HDRS="${HDRS}Origin: ${ORG}\r\n"

          if [ -n "$URL" ] && [ "$URL" != "null" ]; then
            ffmpeg -hide_banner -loglevel error \
              -reconnect 1 -reconnect_streamed 1 -reconnect_at_eof 1 \
              -rw_timeout 15000000 -user_agent "Mozilla/5.0" \
              -headers "$HDRS" -i "$URL" -t $DURATION \
              -vn -c:a aac -b:a 128k "$OUT" || exit 1
          else
            echo "No m3u8 captured; trying Streamlink..."
            PAGE_URL="${{ inputs.url }}"
            streamlink --http-header "Cookie=$CK" --http-header "Referer=$REF" --http-header "Origin=$ORG" "$PAGE_URL" best -O | \
              ffmpeg -hide_banner -loglevel error -i - -t $DURATION -vn -c:a aac -b:a 128k "$OUT" || exit 1
          fi

          echo "out_file=$OUT" >> $GITHUB_OUTPUT

      - name: Transcribe with Whisper
        run: |
          FILE=$(ls -1 recordings/event-*.m4a | tail -n 1)
          whisper "$FILE" --model "${{ inputs.model }}" \
            --task transcribe \
            --output_format all \
            --output_dir recordings \
            --verbose False

      - name: Install diarization deps
        if: ${{ inputs.diarize == true }}
        run: |
          pip install --index-url https://download.pytorch.org/whl/cpu torch torchvision torchaudio
          pip install pyannote.audio==3.* numpy==1.*

      - name: Run diarization
        if: ${{ inputs.diarize == true }}
        env:
          HF_TOKEN: ${{ secrets.HF_TOKEN }}
          MAX_SPK:  ${{ inputs.max_speakers }}
        run: |
          python <<'PY'
          import os, json
          from pathlib import Path
          from pyannote.audio import Pipeline

          out_dir = Path("recordings")
          audio = sorted(out_dir.glob("event-*.m4a"))[-1]
          token = os.environ["HF_TOKEN"]
          n = os.environ.get("MAX_SPK","0")
          num_speakers = int(n) if n.isdigit() and int(n) > 0 else None

          pipeline = Pipeline.from_pretrained("pyannote/speaker-diarization-3.1", use_auth_token=token)
          diarization = pipeline(str(audio), num_speakers=num_speakers)

          with open(out_dir / "event-diarized.txt","w") as f:
              for turn,_,speaker in diarization.itertracks(yield_label=True):
                  f.write(f"{speaker} [{turn.start:.1f}-{turn.end:.1f}]\n")
          PY

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: audio-and-transcripts
          path: recordings/*
          retention-days: 14

      - name: Email completion notice
        if: ${{ always() }}
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.SMTP_SERVER }}
          server_port: ${{ secrets.SMTP_PORT }}
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          from: ${{ secrets.MAIL_FROM }}
          to: ${{ secrets.MAIL_TO }}
          secure: true
          subject: "ðŸŽ§ [${{ github.workflow }}] â€” ${{ job.status }}"
          html_body: |
            <h3>Workflow finished: <b>${{ github.workflow }}</b></h3>
            <ul>
              <li><b>Status:</b> ${{ job.status }}</li>
              <li><b>Repository:</b> ${{ github.repository }}</li>
              <li><b>Event URL:</b> ${{ inputs.url }}</li>
              <li><b>Duration:</b> ${{ inputs.probe_seconds != '0' && format('{0}s (probe)', inputs.probe_seconds) || format('{0} min', inputs.minutes) }}</li>
              <li><b>Artifacts:</b> audio-and-transcripts</li>
              <li><b>Run:</b> <a href="https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}">Open in GitHub</a></li>
            </ul>
          attachments: |
            recordings/page_after_capture.jpg
            recordings/event-diarized.txt
            recordings/*.txt
